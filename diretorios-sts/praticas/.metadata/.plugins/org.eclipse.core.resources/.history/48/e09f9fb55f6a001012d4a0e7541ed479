package com.ufersa.amqpservice;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.HashMap;
import java.util.Map;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.DeliverCallback;

@RestController
@RequestMapping("/amqpservice")
public class AMQPController {

    private static final String ARQUIVO_DADOS = "rabbitmq/dados_recebidos.txt";

    // Broker original (API Gateway)
    private final String brokerOrigemHost = "localhost";
    private final int brokerOrigemPort = 5672;

    // Broker cliente (novo broker onde publica as mensagens)
    private final String brokerClienteHost = "localhost";
    private final int brokerClientePort = 5673;

    private final String filaOrigem = "dados_processados_todos"; // exemplo, pode ser parametrizado

    private com.rabbitmq.client.Connection conexaoOrigem;
    private com.rabbitmq.client.Connection conexaoCliente;
    private Channel canalOrigem;
    private Channel canalCliente;

    public AMQPController() throws Exception {
        inicializarConexoes();
        iniciarConsumo();
    }

    private void inicializarConexoes() throws Exception {
        // Conexão com broker origem (API Gateway)
        ConnectionFactory factoryOrigem = new ConnectionFactory();
        factoryOrigem.setHost(brokerOrigemHost);
        factoryOrigem.setPort(brokerOrigemPort);
        conexaoOrigem = factoryOrigem.newConnection();
        canalOrigem = conexaoOrigem.createChannel();

        // Conexão com broker cliente (onde publica para clientes)
        ConnectionFactory factoryCliente = new ConnectionFactory();
        factoryCliente.setHost(brokerClienteHost);
        factoryCliente.setPort(brokerClientePort);
        conexaoCliente = factoryCliente.newConnection();
        canalCliente = conexaoCliente.createChannel();

        // Declara fila no broker cliente (mesmo nome da fila origem, ou outro que desejar)
        canalCliente.queueDeclare(filaOrigem, true, false, false, null);
    }

    private void iniciarConsumo() throws IOException {
        System.out.println("AMQP Service consumindo mensagens do broker origem...");
        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            String mensagem = new String(delivery.getBody(), StandardCharsets.UTF_8);
            System.out.println("Mensagem recebida do broker origem: " + mensagem);

            salvarEmArquivo(mensagem);
            publicarNoBrokerCliente(mensagem);
        };

        canalOrigem.basicConsume(filaOrigem, true, deliverCallback, consumerTag -> {});
    }

    private synchronized void salvarEmArquivo(String dado) {
        File dir = new File("rabbitmq");
        if (!dir.exists()) {
            dir.mkdirs();
        }

        File arquivo = new File(dir, "dados_recebidos.txt");

        try (FileWriter fw = new FileWriter(arquivo, true);
             BufferedWriter bw = new BufferedWriter(fw);
             PrintWriter out = new PrintWriter(bw)) {

            out.println(dado);

        } catch (IOException e) {
            System.out.println("Erro ao salvar no arquivo: " + e.getMessage());
        }
    }

    private void publicarNoBrokerCliente(String dado) throws IOException {
        canalCliente.basicPublish("", filaOrigem, null, dado.getBytes(StandardCharsets.UTF_8));
        System.out.println("Mensagem publicada no broker cliente.");
    }

    @GetMapping("/broker")
    public Map<String, String> obterBrokerRabbitMQ() {
        Map<String, String> response = new HashMap<>();
        response.put("host", brokerClienteHost);
        response.put("port", String.valueOf(brokerClientePort));
        return response;
    }

    @GetMapping("/historico")
    public ResponseEntity<String> obterHistorico() {
        File arquivo = new File("rabbitmq/dados_recebidos.txt");
        if (!arquivo.exists()) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Arquivo de histórico não encontrado.");
        }

        try {
            String conteudo = Files.readString(arquivo.toPath(), StandardCharsets.UTF_8);
            return ResponseEntity.ok(conteudo);
        } catch (IOException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Erro ao ler o arquivo de histórico.");
        }
    }
}


