package com.ufersa.amqpservice;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.ConnectionFactory;

import jakarta.annotation.PostConstruct;

@RestController
@RequestMapping("/amqpservice")
public class AMQPController {

    private static final String ARQUIVO_DADOS = "rabbitmq/dados_recebidos.txt";

    // Broker origem (API Gateway)
    private final String brokerOrigemHost = "localhost";
    private final int brokerOrigemPort = 5672;

    // Broker cliente (onde publica)
    private final String brokerClienteHost = "localhost";
    private final int brokerClientePort = 5673;

    // Filas origem que serão consumidas
    private final List<String> filasOrigem = List.of(
        "dados_processados_todos",
        "dados_processados_norte",
        "dados_processados_sul",
        "dados_processados_leste",
        "dados_processados_oeste"
    );

    private com.rabbitmq.client.Connection conexaoOrigem;
    private com.rabbitmq.client.Connection conexaoCliente;
    private Channel canalOrigem;
    private Channel canalCliente;
    
    public AMQPController() {
    }

    @PostConstruct
    public void inicializar() {
        try {
            inicializarConexoes();
            iniciarConsumo();
        } catch (Exception e) {
            // Log de erro para não travar a aplicação na inicialização
            System.err.println("Erro ao inicializar conexões RabbitMQ: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void inicializarConexoes() throws Exception {
        // Conexão com broker origem
        ConnectionFactory factoryOrigem = new ConnectionFactory();
        factoryOrigem.setHost(brokerOrigemHost);
        factoryOrigem.setPort(brokerOrigemPort);
        conexaoOrigem = factoryOrigem.newConnection();
        canalOrigem = conexaoOrigem.createChannel();

        // Conexão com broker cliente
        ConnectionFactory factoryCliente = new ConnectionFactory();
        factoryCliente.setHost(brokerClienteHost);
        factoryCliente.setPort(brokerClientePort);
        conexaoCliente = factoryCliente.newConnection();
        canalCliente = conexaoCliente.createChannel();

        // Declara filas no broker cliente com prefixo "cliente_"
        for (String filaOrigem : filasOrigem) {
            String filaCliente = "cliente_" + filaOrigem.substring("dados_processados_".length());
            canalCliente.queueDeclare(filaCliente, true, false, false, null);
        }
    }

    private void iniciarConsumo() throws IOException {
        System.out.println("AMQP Service consumindo mensagens do broker origem...");
        for (String filaOrigem : filasOrigem) {
            canalOrigem.basicConsume(filaOrigem, true, (consumerTag, delivery) -> {
                String mensagem = new String(delivery.getBody(), StandardCharsets.UTF_8);
                System.out.println("Mensagem recebida da fila " + filaOrigem + ": " + mensagem);

                salvarEmArquivo(mensagem);

                String filaCliente = "cliente_" + filaOrigem.substring("dados_processados_".length());
                publicarNoBrokerCliente(filaCliente, mensagem);
            }, consumerTag -> {});
        }
    }

    private synchronized void salvarEmArquivo(String dado) {
        File dir = new File("rabbitmq");
        if (!dir.exists()) {
            dir.mkdirs();
        }

        File arquivo = new File(dir, "dados_recebidos.txt");

        try (FileWriter fw = new FileWriter(arquivo, true);
             BufferedWriter bw = new BufferedWriter(fw);
             PrintWriter out = new PrintWriter(bw)) {

            out.println(dado);

        } catch (IOException e) {
            System.out.println("Erro ao salvar no arquivo: " + e.getMessage());
        }
    }

    private void publicarNoBrokerCliente(String filaCliente, String dado) throws IOException {
        canalCliente.basicPublish("", filaCliente, null, dado.getBytes(StandardCharsets.UTF_8));
        System.out.println("Mensagem publicada na fila cliente: " + filaCliente);
    }

    @GetMapping("/broker")
    public Map<String, String> obterBrokerRabbitMQ() {
        Map<String, String> response = new HashMap<>();
        response.put("host", brokerClienteHost);
        response.put("port", String.valueOf(brokerClientePort));
        return response;
    }

    @GetMapping("/historico")
    public ResponseEntity<String> obterHistorico() {
        File arquivo = new File("rabbitmq/dados_recebidos.txt");
        if (!arquivo.exists()) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Arquivo de histórico não encontrado.");
        }

        try {
            String conteudo = Files.readString(arquivo.toPath(), StandardCharsets.UTF_8);
            return ResponseEntity.ok(conteudo);
        } catch (IOException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Erro ao ler o arquivo de histórico.");
        }
    }
}



