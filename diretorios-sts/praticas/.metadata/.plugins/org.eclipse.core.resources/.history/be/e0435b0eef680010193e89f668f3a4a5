package com.ufersa.apigateway.services;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.List;

import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.MqttCallback;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.cloud.client.ServiceInstance;
import com.ufersa.apigateway.constants.GlobalConstants;

import jakarta.annotation.PostConstruct;

@Service
public class CentroDeDados implements MqttCallback {

    private final String HOST_BD = "localhost";
    private final int PORTA_BD = GlobalConstants.PORTA_BD;

    private final RestTemplate restTemplate;
    private final DiscoveryClient discoveryClient;

    public CentroDeDados(RestTemplate restTemplate, DiscoveryClient discoveryClient) {
        this.restTemplate = restTemplate;
        this.discoveryClient = discoveryClient;
    }

    @PostConstruct
    public void iniciar() {
        System.out.println("Centro de dados iniciado via Spring Boot.");
        registrarLog("Centro de dados inicializado.");
    }

    public void processarDadoBruto(String dadoBruto) {
        String dadoNormalizado = normalizarDado(dadoBruto);
        if (dadoNormalizado != null) {
            distribuirParaUsuarios(dadoNormalizado);
            enviarParaBanco(dadoNormalizado);
        }
    }

    private void distribuirParaUsuarios(String dado) {
        try {
            // Descobrir os serviços via Eureka
            List<ServiceInstance> mqttInstances = discoveryClient.getInstances("servico-mqtt");
            List<ServiceInstance> rabbitInstances = discoveryClient.getInstances("servico-rabbitmq");

            if (!mqttInstances.isEmpty()) {
                String mqttUrl = mqttInstances.get(0).getUri().toString() + "/publicar";
                restTemplate.postForObject(mqttUrl, dado, String.class);
            }

            if (!rabbitInstances.isEmpty()) {
                String rabbitUrl = rabbitInstances.get(0).getUri().toString() + "/publicar";
                restTemplate.postForObject(rabbitUrl, dado, String.class);
            }

            registrarLog("Centro de dados distribuiu o dado " + dado + " via serviços descobertos.");
        } catch (Exception e) {
            registrarLog("Erro ao distribuir dado: " + e.getMessage());
            System.out.println("Erro ao distribuir dado: " + e.getMessage());
        }
    }

    private void enviarParaBanco(String dadoFormatado) {
        try (Socket socket = new Socket(HOST_BD, PORTA_BD);
             PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
            out.println(dadoFormatado);
        } catch (IOException e) {
            registrarLog("Erro ao enviar para o banco: " + e.getMessage());
            System.out.println("Erro ao enviar para o banco: " + e.getMessage());
        }
    }

    private String normalizarDado(String dadoBruto) {
        double temperatura, umidade, pressao, radiacao;
        String regiao = "INDEFINIDA";

        try {
            String[] partes;
            if (dadoBruto.contains("_")) {
                partes = dadoBruto.split("_");
                regiao = "NORTE";
            } else if (dadoBruto.startsWith("(")) {
                partes = dadoBruto.replaceAll("[()]", "").split(";");
                regiao = "SUL";
            } else if (dadoBruto.startsWith("{")) {
                partes = dadoBruto.replaceAll("[{}]", "").split(",");
                regiao = "LESTE";
            } else if (dadoBruto.contains("#")) {
                partes = dadoBruto.split("#");
                regiao = "OESTE";
            } else {
                return null;
            }

            pressao = Double.parseDouble(partes[0]);
            radiacao = Double.parseDouble(partes[1]);
            temperatura = Double.parseDouble(partes[2]);
            umidade = Double.parseDouble(partes[3]);

            return String.format("[%s] [%.2f | %.2f | %.2f | %.2f]", regiao, temperatura, umidade, pressao, radiacao);
        } catch (Exception e) {
            registrarLog("Erro ao normalizar dado: " + e.getMessage());
            return null;
        }
    }

    private void registrarLog(String mensagem) {
        try {
            File logDir = new File("logs");
            if (!logDir.exists()) {
                logDir.mkdirs();
            }

            try (FileWriter fw = new FileWriter("logs/centro_de_dados.txt", true);
                 BufferedWriter bw = new BufferedWriter(fw);
                 PrintWriter out = new PrintWriter(bw)) {
                String timestamp = java.time.LocalDateTime.now().toString();
                out.println("[" + timestamp + "] " + mensagem);
            }
        } catch (IOException e) {
            System.out.println("Erro ao registrar log: " + e.getMessage());
        }
    }
    
	@Override
	public void messageArrived(String topic, MqttMessage message) {
		String dado = new String(message.getPayload());
		System.out.println("Dado recebido de [" + topic + "]: " + dado);

		String dadoNormalizado = normalizarDado(dado);
		if (dadoNormalizado != null) {
			distribuirParaUsuarios(dadoNormalizado);
			enviarParaBanco(dadoNormalizado);
		}
	}

	@Override
	public void connectionLost(Throwable cause) {
		registrarLog("Centro de dados perdeu a conexão com o broker MQTT.");
		throw new RuntimeException(cause);
	}

	@Override
	public void deliveryComplete(IMqttDeliveryToken token) {
	}
}

